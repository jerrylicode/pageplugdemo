{
  "unpublishedCollection": {
    "name": "utils",
    "pageId": "Dashboard",
    "pluginId": "js-plugin",
    "pluginType": "JS",
    "actions": [],
    "archivedActions": [],
    "body": "export default {\n\tgenerateInvoice: async () => {\n\t\tconst doc = new jspdf();\n\t\tdoc.text(\"Hello, World!\", 10, 10);\n\t\tdoc.save(\"example.pdf\");\n\t},\n\n\tdashboardMetrics: async () => {\n\t\tconst orders = await getOrders.run();\n\t\tconst returnsCount = await getReturnsCount.run();\n\n\t\tconst allOrders = orders.length\n\t\tconst fulfilledOrders = orders.filter(o => o.status === 'DELIVERED').length;\n\t\tconst unfulfilledOrders = orders.filter(o => o.status === 'UNFULFILLED').length;\n\t\tconst cancelledOrders = orders.filter(o => o.status === 'CANCELLED').length;\n\t\tconst shippedOrders = orders.filter(o => o.status === 'SHIPPED').length;\n\t\tconst packedOrders = orders.filter(o => o.status === 'PACKED').length;\n\t\tconst totalOrderValue = orders.reduce((a, b) => a + b.total, 0);\n\t\tconst formattedOrderValueAmount = totalOrderValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' }).slice(0, -3);\n\n\t\treturn {\n\t\t\tallOrders,\n\t\t\tfulfilledOrders,\n\t\t\tunfulfilledOrders,\n\t\t\tcancelledOrders,\n\t\t\tshippedOrders,\n\t\t\tpackedOrders,\n\t\t\treturnsCount: returnsCount[0].count,\n\t\t\ttotalOrderValue: formattedOrderValueAmount,\n\t\t}\n\t},\n\n\ttopOrderedProductsChart: async () => {\n\t\tconst orderedProductsCount = await getOrderProductCount.run();\n\n\t\treturn orderedProductsCount.map(p => {\n\t\t\treturn {\n\t\t\t\tx: p.name,\n\t\t\t\ty: p.variant_count\n\t\t\t}\n\t\t})\n\t},\n\n\trevenueChart: async () => {\n\t\tconst revenueByMonth = await getRevenueByMonth.run();\n\t\t\n\t\t  const months = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December'\n  ];\n\n\t\treturn revenueByMonth.map(r => {\n\t\t\treturn {\n\t\t\t\tx: months[parseInt(r.month.substring(5)) - 1] + ' ' + r.month.substring(2, 4),\n\t\t\t\ty: r.total,\n\t\t\t}\n\t\t})\n\t},\n\n\tcalculateAvFulfilTIme: async () => {\n\t\tconst data = await getReturns.run();\n\t\t\n\t\tconst orders = {};\n\n\t\t// Group the orders by their ID\n\t\tdata.forEach((row) => {\n\t\t\tif (!orders[row.order_id]) {\n\t\t\t\torders[row.order_id] = {\n\t\t\t\t\torder_id: row.order_id,\n\t\t\t\t\tfirst_created: row.created,\n\t\t\t\t\tlast_created: row.created,\n\t\t\t\t\tcount: 1,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst order = orders[row.order_id];\n\t\t\t\tif (row.created < order.first_created) {\n\t\t\t\t\torder.first_created = row.created;\n\t\t\t\t}\n\t\t\t\tif (row.created > order.last_created) {\n\t\t\t\t\torder.last_created = row.created;\n\t\t\t\t}\n\t\t\t\torder.count += 1;\n\t\t\t}\n\t\t});\n\n\t\t// Calculate the average time for each order\n\t\tconst averages = [];\n\t\tObject.values(orders).forEach((order) => {\n\t\t\tif (order.count > 1) {\n\t\t\t\tconst firstDate = new Date(order.first_created);\n\t\t\t\tconst lastDate = new Date(order.last_created);\n\t\t\t\tconst diffTime = Math.abs(lastDate - firstDate);\n\t\t\t\tconst diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\t\t\t\taverages.push({ order_id: order.order_id, avg_time: diffDays });\n\t\t\t}\n\t\t});\n\n\t\t// Calculate the overall average time\n\t\tconst total = averages.reduce((acc, { avg_time }) => acc + avg_time, 0);\n\t\tconst overallAvg = total / averages.length;\n\n\t\treturn overallAvg ? overallAvg.toFixed(2) : 1.2;\n\t}\n}",
    "variables": [],
    "userPermissions": []
  },
  "id": "Dashboard_utils",
  "deleted": false,
  "gitSyncId": "64f58f816fbfd93d5cd5b5cf_64f58fc86fbfd93d5cd5b623"
}